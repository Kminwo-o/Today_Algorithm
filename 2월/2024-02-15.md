### 2024-02-15
|                     문제번호                     | 문제이름 | 나의 풀이 |
|:--------------------------------------------:|:----:|:---------: |
| [1915](https://www.acmicpc.net/problem/1915) | 가장 큰 정사각형 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold%20IV/1915.%E2%80%85%EA%B0%80%EC%9E%A5%E2%80%85%ED%81%B0%E2%80%85%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95/%EA%B0%80%EC%9E%A5%E2%80%85%ED%81%B0%E2%80%85%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95.java) |

### 가장 큰 정사각형

예전에 STC LAB 코테에서 1번 문제로 나왔었던 문제와 비슷하다. <br>
당시에는 DP에 대해서 생각을 1도 안하고 완탐으로 풀어서 부분점수만 받았는데 <br>
이게 DP로도 풀 수 있을줄 몰랐다. <br>

가장 중요한 것은 정사각형임을 어떻게 판단 하는 것인가 이다. <br>
1. 우선 IndexError를 방지하기 위해 dp배열을 [n+1][m+1]로 만들어준다. <br>
2. 가장 처음에 확인되는 수는 무조건 dp에 추가한다. <br>
- 이유는 첫 시작이기 때문에 비교군이 없기 때문이다. 따라서 0이면 0, 1이면 1을 넣는다.
<br>
그 다음 부터는 주어진 위치가 1인 경우 자신의 왼쪽, 왼쪽 위, 위를 확인해서 최소 값에 + 1 하여 <br>
dp에 저장하도록 하였다. 이렇게 하면 i,j가 확장되면서 배열의 위에서 부터 아래까지 확인하게되고 <br>
왼쪽, 왼쪽위, 위가 1인 경우 최소값이 1으로 변의 길이가 + 1된 정사각형임을 확인할 수 있다. <br>
<br>
다 풀고 나서 96%에서 틀렸습니다가 발생했는데, 가장 기본적인 최소 케이스를 처리했더니 처리되었다. <br>
n과 m이 모두 1이고 배열의 값이 1인 경우 최소 정사각형의 크기는 1이지만 가장 처음 확인되는 수를 <br>
추가하고 나서는 응답을 갱신하지 않아서 0이 응답으로 나왔다. <br>
첫 값을 넣고 나서 바로 갱신 했더니 맞았습니다가 나왔다.