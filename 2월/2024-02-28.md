### 2024-02-28
|                     문제번호                     | 문제이름 | 나의 풀이 |
|:--------------------------------------------:|:----:|:---------: |
| [10564](https://www.acmicpc.net/problem/10564) |  팔굽혀펴기   | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/10564.%E2%80%85%ED%8C%94%EA%B5%BD%ED%98%80%ED%8E%B4%EA%B8%B0/%ED%8C%94%EA%B5%BD%ED%98%80%ED%8E%B4%EA%B8%B0.java) |

### 팔굽혀펴기
득점 가능한 점수 중에 최댓 값을 구하라고 하는 것을 보니 DP였다. <br>
boolean dp[][]를 만들고 Testcase 마다 새로 할당했다.<br>
점수가 최대 5000까지 가능하고 m은 10개 뿐이지만 중복으로 점수가 쌓일 경우를 생각해 [200][5001]로 만들었는데도 인덱스 에러가 났다. 그래서 아예 여유롭게 [501][5001]로 설정했더니 통과되었다. <br>
<br>
문제 풀이 방식이 좀 어려웠다. <br>
for 문을 통해 이전 점수에 availableScore[i]를 더하고 했던 팔굽혀펴기 + 새로운 점수를 더해서 기억해야했기에 BFS 방식을 사용했다. 즉, BFS + DP라고 볼 수 있다. IF 문을 통해 n보다 높은 팔굽혀펴기거나 이미 가능한 점수일 경우는 continue해서 시간을 줄였다. <br>
<br>
골드 상위 문제는 너무 어렵다. <br>