### 2024-04-08
|                      문제번호                      | 문제이름 | 나의 풀이  |
|:----------------------------------------------:|:----:|:------:|
| [12904](https://www.acmicpc.net/problem/12904) | A와 B | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/12904.%E2%80%85A%EC%99%80%E2%80%85B/A%EC%99%80%E2%80%85B.java) |

### A와 B

풀이는 다음과 같다.
> 1. S -> T가 아닌 T -> S가 가능한지 확인한다. S -> T는 매번 분기를 나눠확인해야하지만 T -> S를 찾는 경우 끝자리가 B이면 -후 reverse, 끝자리가 A면 그냥 -를 하면 되기 때문이다.
> 2. while문을 사용해 S와 T의 길이가 같아질 때 까지반복한다.
> 3. 길이가 같아졌을 때, S와 T가 equals 하다면 1을 그렇지 않으면 0을 반환한다.

사고력이 좀 필요한 그리디였다고 생각한다. 문자열을 계속 dfs로 붙이고 떼고하면 시간초과가 확실할 것 같아서 어떻게 풀어야할지 고민을 좀 많이했다.<br>
<br>
반대로 T에서 S로 가는 과정을 생각했더니 B가 붙은 경우는 무조건 뒤집히고 B가 추가된 것이고 A가 붙은 경우는 그냥 붙은거기 때문에 T -> S로 가는 것이 더 쉬움을 발견했고 통과되었다.