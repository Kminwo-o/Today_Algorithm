### 2024-03-15
|                    문제번호                     |  문제이름  | 나의 풀이  |
|:-------------------------------------------:|:------:|:------:|
| [2146](https://www.acmicpc.net/problem/2146) | 다리 만들기 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/2146.%E2%80%85%EB%8B%A4%EB%A6%AC%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0/%EB%8B%A4%EB%A6%AC%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0.java) |

### 다리 만들기
bfs로 우선 섬을 모두 탐색해서 섬에 번호를 달아주었다. 그리고 섬인 부분에서 네 방향 탐색을 시도해 0인 부분은 bfs를 돌게하여 제일 짧은 거리를 answer 값에 담았다.<br>
문제가 어렵지는 않았지만 효율적으로 설계할 방법이 떠오르지 않았다. 일단 n이 최대 100이었기 떄문에 시간초과가 날 것 같지는 않아서 거의 bfs + 백트래킹 느낌으로 풀이했다. <br>
<br>
풀이 이후 메모리와 시간이 마음에 들지 않아 확인하니 역시나 메모리사용량과 시간이 절반 이하로 해결된 풀이들이 있었다.<br>
<br>
나의 풀이와 비교해보니 bfs의 visited방문에서 차이가 있었다. 나는 bfs를 돌고 나면 0인 부분들을 다시 false로 만들기위해 visited = new boolean[n][n]을 하여 매번 초기화시켰는데 80000메모리에 200ms 결과인 코드는 int[][]으로 하여 visited[nx][ny]가 cnt보다 높은경우에만 진행하도록 해서 재할당 없이 풀이하였다.
<br><br>
이렇게 하면 확실히 메모리를 추가로 할당하지않고 cnt보다 높은 경우 진행하지 않음으로써 불필요한 시행을 방지할 수 있다.
확실히 골드 3 이상의 문제에서는 배울 것들이 많은것 같다. <br>
