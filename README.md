### 2024-03-25
|                     문제번호                     | 문제이름  | 나의 풀이  |
|:--------------------------------------------:|:-----:|:------:|
| [2504](https://www.acmicpc.net/problem/2504) | 괄호의 값 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/2504.%E2%80%85%EA%B4%84%ED%98%B8%EC%9D%98%E2%80%85%EA%B0%92/%EA%B4%84%ED%98%B8%EC%9D%98%E2%80%85%EA%B0%92.java) |

### 괄호의 값

실력이 죽은건지, 아니면 자료구조 활용을 잘 못하는 건지 골드 5임에도 굉장히 어려웠다고 느껴진다.<br>
<br>
풀이는 다음과 같다.
> 1. 입력 받은 괄호를 확인한다. "(" 라면 num에 * 2을 "["라면 * 3 해서 더 해야할 숫자를 만들어준다. 
> 2. 닫는 괄호과 나오는 경우 스택이 비어있거나 가장 최근의 여는 괄호가 동일하지 않다면 잘못된 괄호임으로 flag를 true로 바꾸고 탐색을 끝낸다.
> 3. 그렇지 않은 경우 input값을 확인하여 이전 괄호가 동일하면 answer에 값을 더해주고 그 외에는 이미 계산이 들어간 경우이기 대문에 stack에서
>   pop()하고 num을 나눠준다.

문제 구조는 그렇게 어렵지 않은데 구현방식이 조금 어렵다고 느껴졌다. <br>
```java
(()[[]])([]) 의 경우
2 * (2 + (3 * 3)) + 2 * 3 이므로
(2 * 11) + (6) = 28이 되게하여 계산을 하고자 했다.
```
그러나 실제로 숫자를 곱해야하는 순간과 더해야하는 순간에 우선순위가 되는 숫자만 묶어 계산해주는 것이 어려웠다.<br>
<br>
이를 해결하기 위해서 num이라는 숫자형을 하나 만들어서 계산하는데 사용했다.<br>
```java
(()[[]])([]) 의 경우
(2 * 2) + (2 * 3 * 3) + (2 * 3) 으로 되게하여
)나 ]를 통해서 answer에 더해주고 나면 /=를 통해서 곱해야하는 숫자를 줄였다.
```
위의 방식으로 계산되는 방법도 분명 있겠지만 나는 생각해내지 못했다. BFS, DFS는 열심히 사용하지만 자료구조를 제대로 잘 쓰고 구현해낼 줄 아는가에 대해 생각해보게 되었다.