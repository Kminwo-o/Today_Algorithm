## 2024-05-03
|                     문제번호                     |   문제이름    | 나의 풀이  |
|:--------------------------------------------:|:---------:|:------:|
| [1005](https://www.acmicpc.net/problem/1005) | ACM Craft | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/1005.%E2%80%85ACM%E2%80%85Craft/ACM%E2%80%85Craft.java) |

## ACM Craft
### 문제 풀이
- 답안 확인 여부 : ❌ <br>
- 문제 풀이 시간 : 1시간 21분

### 코드 작성시 도전한 풀이 방법
<details>
<summary> 풀이 방법 </summary>
<div markdown="1">

- 도전한 방법 : 위상 정렬
- 실제 풀이 방법 : DP + 위상정렬
> 1. List[] 그래프를 만들어 연결된 빌드를 모두 확인해주고, 갯수만큼 inDegree[idx]++ 해준다.
> 2. dp[] 배열을 통해 n번 째 구조물이 완성되기 위해서 필요한 시간을 갱신해준다. 
>   - 갱신이 없으면 이전 건물들이 최종으로 완성된 시간을 구할 수 없음
> 3. 우선 inDegree[idx]가 0인 건물들 == 선행 해야하는 건물이 없는 건물들을 모두 queue에 추가하고 해당 건물이 완성되는데 걸리는 시간을 dp에 더해준다.
>    - 이후 while 문을 통해 queue가 비어있지 않다면 로직이 반복되도록 만든다. 이 때, 현재 완성된 건물 build가 == w 라면 더 이상 반복할 필요가 없기 때문에 break 하여 값을 구해준다. 
> 4. graph[build]를 foreach문으로 가져와서 해당 build가 완성됬을 때 연결되어 지을 수 있는 건물들의 inDegree 수치를 -1 해준다.
> 5. -1한 건물은 이전 값과 build 건물 완성 시간 + 지을 건물 시간을 비교해 더 높은 값으로 바꿔준다.
>   - 필요 건물이 모두 완성되야 next 건물을 지을 수 있기 때문에 max값으로 최대 걸리는 시간으로 바꿔줘야한다.
> 6. 만약 inDegree[next]가 0이라면 해당 건물은 완성된 것이기 때문에 queue에 추가해준다.
> 7. w까지의 완성이 끝나면 break가 걸리고 모든 testcase가 끝나면 한번에 sb를 출력하도록 한다.
</div>
</details>

### 문제 풀이시 주의점
1. 걸리는 최소시간을 알아내는 문제이지만 완성 시간을 찾을 때는 max로 값을 찾아야한다.
2. 건물의 개수 = n, 건설순서 = k이다.
3. 위상정렬 개념 뿐 아니라 이전 완료 시간과 현재완료시간을 비교하기 위한 배열이 필요하다.

### 코드 작성 시 놓쳤던 부분
- 건물의 개수는 n, 건설 순서의 개수는 k 이다. 그러나 둘 다 n으로 하여 NumberFormat에러가 발생했다.

### 어려움을 느꼈던 부분
- 보자마자 위상정렬을 사용해야한다는 것을 알고 있었다. 그러나 아직 여러개의 개념을 응용해서 로직을 작성하는 것에 익숙하지 않은 것 같다. 위상정렬 개념을 적용하는 것은 어렵지 않았으나 결국 다른 건물이 완성된 이후 새로운 값을 갱신하기 위해 dp 배열이 필요하다는 사실을 깨닫기까지 시간이 좀 걸렸다.