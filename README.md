### 2024-02-21
|                     문제번호                     | 문제이름  | 나의 풀이 |
|:--------------------------------------------:|:-----:|:---------: |
| [1202](https://www.acmicpc.net/problem/1202) | 보석 도둑 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/1202.%E2%80%85%EB%B3%B4%EC%84%9D%E2%80%85%EB%8F%84%EB%91%91/%EB%B3%B4%EC%84%9D%E2%80%85%EB%8F%84%EB%91%91.java) |

### 보석 도둑

상덕이는 보석점을 턴다. 보석은 n개, 가방은 k개 가방마다 담을 수 있는 무게는 다르지만 한 개의 보석만 담을 수 있다.
n과 k가 최대 30만이기 때문에 보석을 매번 확인하는 것은 시간초과가 날 것이라 생각했다. <br>
<br>
우선 정렬을 가장 먼저 생각했다. 담을 수 있는 무게가 낮은 가방에 무게는 낮지만 가격은 높은 보석을 담아가는 것이 가장 좋다.
그래서 보석을 class로 만들어 comparable하여 무게가 같은 경우에는 가격이 비싼 보석이 먼저 오도록, 그렇지 않으면 무게가 낮은 보석을
먼저 오도록 하였다. 가방은 오름차순으로만 정렬하였다. <br>
<br>
이렇게 할 경우 예시 2를 기준으로 했을 때 다음과 같아진다. 
```java
JewelArray : [1, 65], [2, 99], [5, 23]
bag : 2, 10
```
이후에는 한 번 뺐던 보석을 다시 찾지 않으면서 가장 비싼 보석을 먼저 찾을 수 있도록 우선순위 큐를 이용했다.
먼저 for 반복문을 사용해 i가방의 무게를 확인하고 while문으로 idx번째 보석이 i번째 가방보다 무게가 작거나 같으면 우선순위 큐에 넣었다.
더 이상 보석을 추가 할 수 없다면 해당 가방에 넣을 수 있는 보석을 모두 탐색한 것이고, 우선순위 큐를 통해 가장 비싼 보석을 poll 하여 answer에 더해주었다. <br>
<br>
이렇게 하면 이전 배낭에 넣을 수 있는 무게는 이번 배낭에도 넣을 수 있기 때문에 그대로 큐에 넣어두고, 다음 보석이 배낭에 넣을 수 있는가를 판단하여
큐에 추가한다. 그리고 다시 그 중 가잔 비싼 보석을 다시 answer에 더 한다. <br>
<br>
가방 갯수만큼 더 하고 나면 가장 비싸게 들고 갈 수 있는 보석의 합이 구해진다.<br>
<br>
그리디 너무 어렵다. 풀이 방법을 어떻게 해야할지 몰라서 30~40분 동안 방법만 생각한거 같다.<br>
구현은 솔직히 오래 안걸리는데 풀이 방법을 떠올리는게 dp 급으로 어렵다...