## 2024-04-14
|                     문제번호                     | 문제이름  | 나의 풀이  |
|:--------------------------------------------:|:-----:|:------:|
| [1245](https://www.acmicpc.net/problem/1245) | 농장 관리 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/1245.%E2%80%85%EB%86%8D%EC%9E%A5%E2%80%85%EA%B4%80%EB%A6%AC/%EB%86%8D%EC%9E%A5%E2%80%85%EA%B4%80%EB%A6%AC.java) |

## 농장 관리
### 문제 풀이
- 답안 확인 여부 : ❌ <br>
- 문제 풀이 시간 : 55분

### 코드 작성시 도전한 풀이 방법
<details>
<summary> 풀이 방법 </summary>
<div markdown="1">

- BFS : 배열 탐색을 통해 봉우리의 개수를 알아내야하는 문제이기에 곧 바로 BFS나 DFS를 떠올렸다. N최대 100, M최대 70이기에 DFS도 가능할 것 같으나 더 익숙하고 자신있는 BFS로 풀이하였음.
> 1. 이중 for문으로 0이 아니거나 아직 방문하지 않은 산맥의 경우 BFS를 시행한다.
> 2. Queue에 현재 봉우리 값을 넣고 8방향 탐색을 한다. 이 때, bfs를 시작한 arr[x][y] 값보다 arr[nx][ny]값이 크다면 산봉우리가 아니기 때문에 peak = false;한다.
>   - 이 때, 가장 큰 목적은 해당 값이 산봉우리인지를 알아내는 것과 함께, 같은 집합의 속하는 산맥을 먼저 분리해내는 것이다.
> 3. 같은 값인 경우 같은 집합이기 때문에 queue에 추가하여 탐색킨다.
>   - 이미 산봉우리가 아님이 판별될지라도 같은 집합을 이루는 산맥이 모두 산봉우리가 아님을 증명해야하기 때문에 peak = false 이후에도 같은 값 탐색을 지속적으로 이어나간다.
> 4. queue의 모든 탐색이 끝나면 같은 집합을 알 수 있다. 이 때, peak이 false라면 해당 집합은 산봉우리가 아니기 때문에 answer++; 하지 않는다. 
> 5. 모든 시작점에서 for문이 끝나면 answer를 출력한다.
</div>
</details>

### 문제 풀이시 주의점
1. 인접하다고 쓰여져 있지만 x좌표와 y좌표 차이 모두 1 이하인 경우이기 때문에 사실 4방향이 아닌 8방향이다.
2. 같은 산맥에서 더 높은 산맥이 있다 하더라도 집합의 주변 값이 모두 집합의 값보다 적다면 집합은 봉우리이다.
    - 즉, 같은 산맥 내에 여러 봉우리가 존재할 수 있음

### 코드 작성 시 놓쳤던 부분
1. 처음에 작성했을 시에는 arr[x][y] 보다 arr[nx][ny] 값이 크다면 바로 return하도록 작성하여 같은 집합의 다른 위치가 산맥이 아님을 증명하지 않고 bfs를 종료해서 처리시간이 보다 오래걸렸다.
2. 바로 return하도록 하였기 때문에 visited = true로 인해 체크하지 못하는 상황이 생길까봐 bfs마다 visited를 새로 할당해주었다. (visited = new boolean[n][m]) 이로 인해 memory 값이 불필요하게 많이 사용되었다.
- ex) 아래의 경우, 처음 왼쪽 산맥과 오른쪽 산맥 2 산맥이 존재, 그러나 idx[1][1]이나 idx[0][2]의 위치에서 2가 있음을 확인하고 bfs를 멈추는 경우 idx[2][0]은 이미 true값을 가진 idx[1][1]을 판별하지 못하고 산봉우리로 인식됨.
```java
1 1 1 0 1
0 1 2 0 1
1 0 0 0 1
```

### 어려움을 느꼈던 부분
산봉우리임을 판별하거나 판별하지 않거나 할 때, 집합 모두가 그렇거나 그렇지 않음을 확인할 수 있어야한다. 이를 충족할 수 있는 방법을 생각해내기 어려웠다. 
만약 n과 m의 최대 값이 1000이고 시간 제한이 1초 or 메모리 제한값이 낮았다면 처음 시도했을 때 틀렸습니다가 나왔을 수도 있다고 생각한다.