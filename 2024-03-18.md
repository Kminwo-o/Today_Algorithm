### 2024-03-18
|                      문제번호                      | 문제이름  | 나의 풀이  |
|:----------------------------------------------:|:-----:|:------:|
| [1939](https://www.acmicpc.net/problem/1939) | 중량제한 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/1939.%E2%80%85%EC%A4%91%EB%9F%89%EC%A0%9C%ED%95%9C/%EC%A4%91%EB%9F%89%EC%A0%9C%ED%95%9C.java) |

### 중량제한
운동을 다시 시작하고 빠르게 무게 복귀를 하고 있다. 스쿼트 rm 100kg, 데드리프트 rm 130kg, 벤치 rm 70kg 복귀 기념으로 중량제한 문제를 풀었다. <br>
이분탐색 문제해결능력이 부족한 것 같아서 이분 탐색 문제를 최대한 풀고자 한다. 우선 문제 풀이는 다음과 같다. <br>
>1. 도로 값을 받으면서 min과 max 값을 갱신하여 이분 탐색을 진행하여 최대로 옮길 수 있는 무게를 찾아낸다.
>2. 이 과정에서 start부터 시작해 end로 도달할 수 있는 경우에만 mid 값이 증가해야 하기 때문에 bfs를 사용하여 도달 가능여부를 확인한다.

풀고 나면 어렵지 않지만 항상 처음에 이분 탐색을 어떤식으로 적용해야할지, 이분탐색으로 어떤 값을 구해야할지 항상 설계하기가 어렵다. 이분 탐색을 활용해서 1,000,000,000까지 늘어날 수 있는 무게를 압축하여 가능 여부를 구함으로써 시간이 단축되긴 했지만 이것보다 더 효율적인 방법이 있을 것 같아서 확인해보니 분리 집합으로 풀이가 가능했다. <br>
<br>
분리집합의 풀이는 시간적인 측면에서 더 효율적이진 않았으나 메모리 효율면에서 좀더 좋은 결과를 가져왔다. visited를 할당 및 재할당하는 로직이 없어서 그런 것 같다.