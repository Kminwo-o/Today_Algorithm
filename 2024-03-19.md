### 2024-03-19
|                      문제번호                      | 문제이름  | 나의 풀이  |
|:----------------------------------------------:|:-----:|:------:|
| [2234](https://www.acmicpc.net/problem/2234) | 성곽 | [풀이](https://github.com/Kminwo-o/BaekJoon-Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/2234.%E2%80%85%EC%84%B1%EA%B3%BD/%EC%84%B1%EA%B3%BD.java) |

### 성곽

단순 BFS활용 구분 문제라고 생각했는데 갈 수 있는 방향을 어떻게 구분해줄지 생각하는 것이 어려웠다. <br>
풀이는 다음과 같다.
> 1. 각 위치에서 사방탐색으로 위치를 이동하며 방 번호를 입력한다.
> 2. 방 번호 입력 이후, for문으로 roomNumber만큼 순회하며 가장 큰 방의 크기를 구하고 입력한다.
> 3. 각 위치마다 사방탐색으로 방 번호가 다른 경우 벽을 두고 붙어있다고 판단, 두 방의 합 크기를 구한다. 그렇게 두 방의 합이 가장 큰 값을 입력하고 출력한다.

room[i][j] 값이 0인 경우 아직 방 번호가 입력되지 않은 상태이기에 room[i][j]가 0인 경우에 BFS를 진행했다. boolean 대신 int를 사용해 방 번호를 확인할 수 있도록 했다. <br>
<br>
문제는 사방 탐색을 어떻게 할 것인가 였다. 처음에는 arr을 3차원 배열으로 만들어서 각 방향마다 이동 가능하면 true, 그렇지 않으면 false를 저장하여 가능여부를 생각해볼까 했으나 해당 방법은 메모리가 추가로 발생하기 때문에 다른 방법을 먼저 생각하고 불가능하면 도전해보기로 하였다. (50 * 50 인 방에서는 메모리가 매우 크게 더 필요해짐...)<br>
<br>
우선 0~15까지 방의 상태를 적어보았다. 그리고 이동할 수 없는 방향은 다음과 같았다.
```plain
0 : (사방 이동 가능)
1 : (서) - // 0
2 : (북) - // 1 ** 0
3 : (서, 북) - // 1 ** 0
4 : (동) - // 2 ** 1
5 : (서, 동) - // 2 ** 1
6 : (북, 동) - // 3 ** 1
7 : (서, 북, 동) - // 3 ** 1
8 : (남) - // 4 ** 2
9 : (서, 남) - // 4 ** 2
10 : (북, 남) - // 5 ** 2
11 : (서, 북, 남) - // 5 ** 2
12 : (동, 남) - // 6 ** 3
13 : (서, 동, 남) - // 6 ** 3
14 : (북, 동, 남) - // 7 ** 3
15 : (서, 북, 동, 남) - // 7 ** 3 
```
이 15가지 경우의 수를 모두 입력해줄 수도 있지만 if문이 많아지므로 보다 효율적인 설계를 하고자 했다. <br>
우선 첫 번째로, 처음에 % 2 == 0인 경우는 모두 서쪽으로의 이동이 가능했다. 따라서 for문을 4번 반복하여 처음으로 value % 2가 0인 경우는 서쪽으로 이동이 가능하다. <br>
다음으로 value /= 2를 한 경우 value == 0 이면 북쪽으로 이동이 가능하다. (// 이후 6, 4, 2인 경우 북쪽이 모두 뚫려있음), 그 다음으로 또 value /= 2를 하고난 후 value == 0이면 동쪽으로 이동이 가능해진다. (** 이후 2, 0인 경우)<br>
<br>
이런식으로 총 4번의 for문을 진행하며 i == 0이면 서쪽을 추가, i == 1이면 북쪽을 추가해주는 형태로 진행하면 해당 지역의 %를 사용한 수식으로 바로바로 4방향 탐색이 가능했다.<br>
<br>
방을 구분하고 난 이후는 간단했다. fori & forj & fork로 각 위치마다 사방향 탐색을 해주고 방번호가 같지 않으면 합쳐보고 값이 더 큰 것을 answer에 담아서 가장 큰 방의 크기를 구한다.<br>
<br>
규칙은 dp에서만 구할 줄 알았는데 BFS에서 구조가 아닌 규칙을 찾아볼 줄은 몰랐다. 안까먹고 이런 형태의 문제가 나오면 바로 풀 수 있도록 기억해야겠다.